        -:    0:Source:super_list.c
        -:    0:Graph:super_list.gcno
        -:    0:Data:super_list.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "string.h"
        -:    2:#include "assert.h"
        -:    3:#include "stdlib.h"
        -:    4:#include "inttypes.h"
        -:    5:#include "stdio.h"
        -:    6:#include "immintrin.h"
        -:    7:
        -:    8:#include "mylist.h"
        -:    9:
        -:   10:
        -:   11:
        -:   12:
        -:   13:#define used_item(lst) 0
        -:   14:#define free_item(lst) 1
        -:   15:
        -:   16:#define used_head(lst) ((lst)->items[used_item(lst)].next)
        -:   17:#define used_tail(lst) ((lst)->items[used_item(lst)].prev)
        -:   18:
        -:   19:#define free_head(lst) ((lst)->items[free_item(lst)].next)
        -:   20:#define free_tail(lst) ((lst)->items[free_item(lst)].prev)
        -:   21:
        -:   22:
        -:   23:#define DPRINTF(...)
        -:   24:// #define DPRINTF printf
        -:   25:
        -:   26:
        -:   27:#define ITEM_SIZE 16
        -:   28:#define ITEM_VALUES_COUNT (ITEM_SIZE - 3)
        -:   29:#define ITEM_MIN_VALUES_COUNT (ITEM_VALUES_COUNT / 2)
        -:   30:
        -:   31:#define ITERATOR_SHIFT 4
        -:   32:
        -:   33:struct expanded_iterator_t
        -:   34:{
        -:   35:    int block, index;
        -:   36:};
        -:   37:
        -:   38:__attribute__((always_inline)) __inline__ 
        -:   39:void deconstruct_iterator(iterator_t it, int *block, int *item)
        -:   40:{
460014608*:   41:    *block = (it >> ITERATOR_SHIFT);
460014608*:   42:    *item = (it & ((1 << ITERATOR_SHIFT) - 1));
        -:   43:}
        -:   44:
        -:   45:__attribute__((always_inline)) __inline__ 
        -:   46:iterator_t construct_iterator(int block, int item)
        -:   47:{
400167806*:   48:    return item | (block << ITERATOR_SHIFT);
        -:   49:}
        -:   50:
        -:   51:
220010044:   52:int is_correct(iterator_t it)
        -:   53:{
220010044:   54:    return it != 0;
        -:   55:}
        -:   56:
        -:   57:
        -:   58:struct item_header
        -:   59:{
        -:   60:    int size, next, prev;
        -:   61:};
        -:   62:
        -:   63:
        -:   64:struct item
        -:   65:{
        -:   66:    struct item_header;
        -:   67:    int value[ITEM_VALUES_COUNT];
        -:   68:};
        -:   69:
        -:   70:
        -:   71:struct list_t
        -:   72:{
        -:   73:    struct item *items;
        -:   74:    int alloc;
        -:   75:    int size;
        -:   76:};
        -:   77:
        -:   78:
        -:   79:/* standart initializators */
    10006:   80:struct list_t *list_create(int32_t capacity)
        -:   81:{    
    10006:   82:    struct list_t *lst = calloc(1, sizeof(*lst));
        -:   83:    
    10006:   84:    lst->alloc = 2;
    10006:   85:    lst->items = calloc(1, 2 * sizeof(*lst->items));
    10006:   86:    lst->size = 0;
        -:   87:
    10006:   88:    lst->items[free_item(lst)].next = free_item(lst);
    10006:   89:    lst->items[free_item(lst)].prev = free_item(lst);
    10006:   90:    lst->items[free_item(lst)].size = 1;
    10006:   91:    lst->items[used_item(lst)].next = used_item(lst);
    10006:   92:    lst->items[used_item(lst)].prev = used_item(lst);
    10006:   93:    lst->items[used_item(lst)].size = 1;
        -:   94:
    10006:   95:    list_reserve(lst, 2 * capacity / ITEM_VALUES_COUNT);
        -:   96:
    10006:   97:    return lst;
        -:   98:}
        -:   99:
    #####:  100:struct list_t *list_create_from_array(int32_t *array, int32_t array_len, int32_t capacity)
        -:  101:{
    #####:  102:    struct list_t *lst = list_create(capacity);
    #####:  103:    for (int i = 0; i < array_len; ++i)
        -:  104:    {
    #####:  105:        list_insert(lst, 2 + i, array[i]);
        -:  106:    }
    #####:  107:    return lst;
        -:  108:}
        -:  109:
    10006:  110:result_t list_free(struct list_t *lst)
        -:  111:{
    10006:  112:    free(lst->items);
    10006:  113:    free(lst);
    10006:  114:    return 0;
        -:  115:}
        -:  116:
 17327954:  117:result_t list_reserve(struct list_t *lst, int32_t capacity)
        -:  118:{
 17327954:  119:    capacity += 2; // add u_item and f_item
 17327954:  120:    if (capacity > lst->alloc)
        -:  121:    {
    45186:  122:        int prev_size = lst->alloc;
    45186:  123:        lst->alloc = 1;
   442384:  124:        while (lst->alloc < capacity)
        -:  125:        {
   397198:  126:            lst->alloc *= 2;
        -:  127:        }
    45186:  128:        struct item *new_ptr = realloc(lst->items, sizeof(*lst->items) * lst->alloc);
    45186:  129:        if (new_ptr == NULL)
        -:  130:        {
    #####:  131:            return 1;
        -:  132:        }
    45186:  133:        lst->items = new_ptr;
        -:  134:        
        -:  135:        /* mark new nodes as free */
        -:  136:        
        -:  137:        // first element
    45186:  138:        lst->items[prev_size].prev = free_tail(lst);
    45186:  139:        lst->items[free_tail(lst)].next = prev_size;
        -:  140:        // last element
    45186:  141:        lst->items[lst->alloc - 1].next = free_item(lst);
    45186:  142:        lst->items[free_item(lst)].prev = lst->alloc - 1;
        -:  143:        // other links
 65862238:  144:        for (int i = prev_size; i < lst->alloc; ++i)
        -:  145:        {
 65817052:  146:            if (i != lst->alloc - 1)
        -:  147:            {
 65771866:  148:                lst->items[i].next = i + 1;
        -:  149:            }
 65817052:  150:            if (i != prev_size)
        -:  151:            {
 65771866:  152:                lst->items[i].prev = i - 1;
        -:  153:            }
 65817052:  154:            lst->items[i].size = 0;
        -:  155:        }
        -:  156:    }
 17327954:  157:}
        -:  158:
        -:  159:/* helping functions */
     5003:  160:int32_t list_size(struct list_t *lst)
        -:  161:{
     5003:  162:    return lst->size;
        -:  163:}
        -:  164:
        -:  165:/* iterators */
 97520044:  166:iterator_t list_head(struct list_t *lst)
        -:  167:{
195040088:  168:    iterator_t res = construct_iterator(used_head(lst), 0);
 97520044:  169:    DPRINTF("ret head=%d\n", res);
 97520044:  170:    DPRINTF(": head_next=%d\n", used_head(lst));
 97520044:  171:    DPRINTF(": alloc=%d\n", lst->alloc);
 97520044:  172:    return res;
        -:  173:}
        -:  174:
 37504773:  175:iterator_t list_tail(struct list_t *lst)
        -:  176:{
 75009546:  177:    iterator_t res = construct_iterator(used_tail(lst), lst->items[used_tail(lst)].size - 1);
 37504773:  178:    DPRINTF("ret tail=%d\n", res);
 37504773:  179:    return res;
        -:  180:}
        -:  181:
125000259:  182:iterator_t list_next(struct list_t *lst, iterator_t it)
        -:  183:{
125000259*:  184:    int block, index;
250000518*:  185:    deconstruct_iterator(it, &block, &index);
125000259*:  186:    index++;
125000259*:  187:    assert(index <= lst->items[block].size);
125000259*:  188:    if (index == lst->items[block].size)
        -:  189:    {
36487631*:  190:        return construct_iterator(lst->items[block].next, 0);
        -:  191:    }
88512628*:  192:    return construct_iterator(block, index);
        -:  193:}
        -:  194:
    #####:  195:iterator_t list_prev(struct list_t *lst, iterator_t it)
        -:  196:{
    #####:  197:    int block, index;
    #####:  198:    deconstruct_iterator(it, &block, &index);
    #####:  199:    assert(index <= lst->items[block].size);
    #####:  200:    if (index == 0)
        -:  201:    {
    #####:  202:        return construct_iterator(lst->items[block].prev, lst->items[lst->items[block].prev].size - 1);
        -:  203:    }
    #####:  204:    return construct_iterator(block, index - 1);
        -:  205:}
        -:  206:
    #####:  207:iterator_t list_move(struct list_t *lst, iterator_t it, int32_t steps)
        -:  208:{    
    #####:  209:    if (steps == 0)
        -:  210:    {
        -:  211:        return it;
        -:  212:    }
    #####:  213:    if (steps < 0)
        -:  214:    {
    #####:  215:        steps *= -1;
    #####:  216:        for (int i = 0; i < steps; ++i)
        -:  217:        {
    #####:  218:            it = list_prev(lst, it);
        -:  219:        }
    #####:  220:        return it;
        -:  221:    }
    #####:  222:    for (int i = 0; i < steps; ++i)
        -:  223:    {
    #####:  224:        it = list_next(lst, it);
        -:  225:    }
        -:  226:    return it;
        -:  227:}
        -:  228:
125004791:  229:int32_t list_get(struct list_t *lst, iterator_t it)
        -:  230:{
125004791*:  231:    int block, index;
250009582*:  232:    deconstruct_iterator(it, &block, &index);
125004791*:  233:    return lst->items[block].value[index];
        -:  234:}
        -:  235:
        -:  236:
        -:  237:/* duplicates block, and return index of first one + it is 100% not full */
 17317948:  238:struct expanded_iterator_t duplicate_block(struct list_t *lst, int block, int index)
        -:  239:{
 17317948:  240:    list_reserve(lst, lst->size + 2);
        -:  241:    
        -:  242:    // int prev = lst->items[block].prev;
 17317948:  243:    int next = lst->items[block].next;
 17317948:  244:    int node = free_head(lst);
        -:  245:
        -:  246:    /* update free list */
 17317948:  247:    lst->items[free_item(lst)].next = lst->items[node].next;
 17317948:  248:    lst->items[lst->items[node].next].prev = free_item(lst);
        -:  249:
        -:  250:    /* array pointers */
 17317948:  251:    lst->items[block].next = node;
 17317948:  252:    lst->items[next].prev = node;
        -:  253:    
        -:  254:    /* update new node */
 17317948:  255:    lst->items[node].prev = block;
 17317948:  256:    lst->items[node].next = next;
        -:  257:    
        -:  258:    /* copy 1/2 of block to new block */
        -:  259:    /* MEGA OPTIMIZATION: !!block is 1 if block != 0 -> than we shouldn't */
        -:  260:    /* remove one fictive element from fitst node - else we need to remove one more */
        -:  261:    /* to right insert to leftmost node */
 17317948:  262:    int size_to_copy = ((lst->items[block].size + (!!block)) >> 1);
 17317948:  263:    int remain_size = lst->items[block].size - size_to_copy;
 17317948:  264:    memcpy(lst->items[node].value, lst->items[block].value + remain_size, sizeof(*lst->items[node].value) * size_to_copy);
        -:  265:
        -:  266:    /* update node sizes */
 17317948:  267:    lst->items[node].size = size_to_copy;
 17317948:  268:    lst->items[block].size = remain_size;
        -:  269:
 17317948:  270:    assert(lst->items[used_item(lst)].size == 1);
 17317948:  271:    assert(lst->items[free_item(lst)].size == 1);
        -:  272:
        -:  273:    /* size_to_copy == block size / 2 < block size <= ITEM_VALUES_COUNT */
 17317948:  274:    assert(lst->items[block].size < ITEM_VALUES_COUNT || 
        -:  275:          (block == used_item(lst) && lst->items[next].size == ITEM_VALUES_COUNT));
        -:  276:
 17317948:  277:    if (index < remain_size)
        -:  278:    {
 11057162:  279:        return (struct expanded_iterator_t){block, index};
        -:  280:    }
  6260786:  281:    return (struct expanded_iterator_t){node, index - remain_size};
        -:  282:}
        -:  283:
        -:  284:/* remove block, return pointer on next block */
    #####:  285:int remove_block(struct list_t *lst, int block)
        -:  286:{
12697215*:  287:    int next = lst->items[block].next;
12697215*:  288:    int prev = lst->items[block].prev;
        -:  289:    
12697215*:  290:    DPRINTF("RM {%d} %d {%d}\n", prev, block, next);
        -:  291:    
        -:  292:    /* update free list */
12697215*:  293:    lst->items[block].next = free_head(lst);
12697215*:  294:    lst->items[block].prev = free_item(lst);
12697215*:  295:    lst->items[free_head(lst)].prev = block; // not swap this string with next one
12697215*:  296:    lst->items[free_item(lst)].next = block;
        -:  297:
        -:  298:    /* update next + prev */
12697215*:  299:    lst->items[prev].next = next;
12697215*:  300:    lst->items[next].prev = prev;
        -:  301:
12697215*:  302:    DPRINTF("RETURN %d {%d}\n", next, prev);
        -:  303:    
12697215*:  304:    return next;
        -:  305:}
        -:  306:
        -:  307:
        -:  308:/* insertion and deletion of elements */
115004789:  309:iterator_t list_insert(struct list_t *lst, iterator_t it, int32_t value)
        -:  310:{
115004789:  311:    DPRINTF("insert %d before IT=%d\n", value, it);
        -:  312:    /* insert to block by iterator */
115004789:  313:    int block, index;
230009578:  314:    deconstruct_iterator(it, &block, &index);
        -:  315:
115004789:  316:    if (block == 0)
        -:  317:    {
    10007:  318:        if (used_tail(lst) == 0)
        -:  319:        {
    10007:  320:            struct expanded_iterator_t exp = duplicate_block(lst, block, 1);
    10007:  321:            block = exp.block;
    10007:  322:            index = exp.index;
        -:  323:        }
        -:  324:        else
        -:  325:        {
        -:  326:            block = used_tail(lst);
        -:  327:        }
        -:  328:        assert(block == used_tail(lst));
        -:  329:        assert(index == 0);
        -:  330:    }
114994782:  331:    else if (lst->items[block].size == ITEM_VALUES_COUNT)
        -:  332:    {
        -:  333:        /* split node */
        -:  334:        /* no clever things: simply split node */
        -:  335:        /* TODO: optimize */
 17307941:  336:        struct expanded_iterator_t exp = duplicate_block(lst, block, index);
 17307941:  337:        block = exp.block;
 17307941:  338:        index = exp.index;
        -:  339:    }
        -:  340:
        -:  341:
115004789:  342:    int size = lst->items[block].size;
        -:  343:
115004789:  344:    assert(size < ITEM_VALUES_COUNT);
115004789:  345:    assert(index <= size);
        -:  346:
        -:  347:    /* now - insert element to array */
115004789:  348:    DPRINTF("insert at: %d of %d, block %d\n", index, ITEM_VALUES_COUNT, block);
115004789:  349:    memmove(lst->items[block].value + index + 1, lst->items[block].value + index, sizeof(*lst->items[block].value) * (size - index));
115004789:  350:    lst->items[block].value[index] = value;
        -:  351:
115004789:  352:    lst->size++;
115004789:  353:    lst->items[block].size++;
        -:  354:
230009578:  355:    return construct_iterator(block, index);
        -:  356:}
        -:  357:
 95004769:  358:iterator_t list_remove(struct list_t *lst, iterator_t it)
        -:  359:{
 95004769:  360:    int block, index;
190009538:  361:    deconstruct_iterator(it, &block, &index);
 95004769:  362:    DPRINTF("rm iterator: %d\n", it);
 95004769:  363:    DPRINTF("removing... from %d [%d]\n", block, index);
        -:  364:    
        -:  365:    /* no clever: if node is empty: remove it */
        -:  366:    /* TODO: strongly optimize */
 95004769:  367:    if (lst->items[block].size == 1)
        -:  368:    {
 12697215:  369:        lst->size--;
 12697215:  370:        return construct_iterator(remove_block(lst, block), 0);
        -:  371:    }
        -:  372:
        -:  373:    /* remove element from node */
 82307554:  374:    int size = lst->items[block].size;
        -:  375:
 82307554:  376:    assert(size > 1);
 82307554:  377:    assert(index < size);
        -:  378:    
        -:  379:    /* update sizes */
 82307554:  380:    lst->size--;
 82307554:  381:    lst->items[block].size--;
        -:  382:    
        -:  383:    /* return next iterator */
 82307554:  384:    if (index + 1 == size)
        -:  385:    {
 12440726:  386:        return construct_iterator(lst->items[block].next, 0);
        -:  387:    }
        -:  388:    
 69866828:  389:    memmove(lst->items[block].value + index, lst->items[block].value + index + 1, sizeof(*lst->items[block].value) * (size - index));
        -:  390:
 69866828:  391:    DPRINTF("new size of %d is %d\n", block, lst->items[block].size);
 69866828:  392:    DPRINTF("items %d %d [%d]\n", lst->items[block].value[0], lst->items[block].value[1], lst->items[block].value[2]);
        -:  393:    
        -:  394:    /* return same iterator - now it points on next element */
 69866828:  395:    return it;
        -:  396:}
        -:  397:
        -:  398:/* call this function at free time, to optimizate structure */
        1:  399:result_t list_optimize(struct list_t *lst)
        -:  400:{
        1:  401:    (void)lst;
        1:  402:    return 0;
        -:  403:}
        -:  404:
        -:  405:
        -:  406:
        -:  407:/* get element by index */
    #####:  408:int32_t list_at(struct list_t *lst, int32_t index)
        -:  409:{
    #####:  410:    iterator_t it = list_move(lst, used_head(lst), index);
    #####:  411:    return list_get(lst, it);
        -:  412:}
